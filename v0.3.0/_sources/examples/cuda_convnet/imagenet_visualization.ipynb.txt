{
 "cells": [
  {
   "cell_type": "markdown",
   "metadata": {},
   "source": [
    "# Visualizing the ImageNet classifier\n",
    "\n",
    "This will open a Tkinter GUI that shows\n",
    "ImageNet images and layers of the classifier.\n",
    "Note that running this notebook requires\n",
    "Tkinter, Theano, and the files located at\n",
    "https://figshare.com/s/cdde71007405eb11a88f\n",
    "and https://figshare.com/s/f343c68df647e675af28."
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "import os\n",
    "\n",
    "from nengo_extras.data import load_ilsvrc2012\n",
    "from nengo_extras.cuda_convnet import CudaConvnetNetwork, load_model_pickle\n",
    "from nengo_extras.gui import image_function\n",
    "from nengo_extras.deepnetworks import ConvLayer, PoolLayer, NeuronLayer\n",
    "from nengo_extras.deepview import Viewer\n",
    "\n",
    "os.environ['THEANO_FLAGS'] = 'device=cuda,floatX=float32'"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "def preprocess(x, scale=255, offset=0):\n",
    "    if x.shape[0] != 3:\n",
    "        x = x.mean(axis=0, keepdims=True)\n",
    "    x = (x + offset) * scale\n",
    "    x = x.transpose((1, 2, 0))  # color channel last\n",
    "    if x.shape[-1] == 1:\n",
    "        x = x[..., 0]\n",
    "    return x.clip(0, 255).astype('uint8')\n",
    "\n",
    "\n",
    "def get_filters_image_fn(filters):\n",
    "    filters = layer.process.filters\n",
    "    fmean, fwidth = filters.mean(), 2 * filters.std()\n",
    "    filter_image_fn = image_function(\n",
    "        filters.shape[1:], preprocess=preprocess,\n",
    "        offset=fwidth - fmean, scale=128. / fwidth)\n",
    "    return filter_image_fn\n",
    "\n",
    "\n",
    "def get_act_image_fn(acts):\n",
    "    act_shape = (1,) + acts.shape[2:]\n",
    "    amean, awidth = acts.mean(), 2 * acts.std()\n",
    "    act_image_fn = image_function(\n",
    "        act_shape, preprocess=preprocess,\n",
    "        offset=awidth - amean, scale=128. / awidth)\n",
    "    return act_image_fn"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- load data\n",
    "# retrieve from https://figshare.com/s/cdde71007405eb11a88f\n",
    "filename = 'ilsvrc-2012-batches-test3.tar.gz'\n",
    "X_test, Y_test, data_mean, label_names = load_ilsvrc2012(filename, n_files=1)\n",
    "\n",
    "X_test = X_test.astype('float32')\n",
    "\n",
    "# crop data\n",
    "X_test = X_test[:, :, 16:-16, 16:-16]\n",
    "data_mean = data_mean[:, 16:-16, 16:-16]\n",
    "image_shape = X_test.shape[1:]\n",
    "\n",
    "# subtract mean\n",
    "X_test -= data_mean\n",
    "\n",
    "# retrieve from https://figshare.com/s/f343c68df647e675af28\n",
    "model_filename = 'ilsvrc2012-lif-48.pkl'\n",
    "cc_model = load_model_pickle(model_filename)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- forward pass\n",
    "n = 100\n",
    "images = X_test[:n]\n",
    "\n",
    "ccnet = CudaConvnetNetwork(cc_model)\n",
    "\n",
    "y = images.reshape((images.shape[0], -1))\n",
    "outputs = []\n",
    "for layer in ccnet.layers:\n",
    "    y = layer.theano_compute(y)\n",
    "    outputs.append(y)"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "metadata": {},
   "outputs": [],
   "source": [
    "# --- create viewer\n",
    "input_image_fn = image_function(image_shape, offset=data_mean, scale=1)\n",
    "viewer = Viewer(images, input_image_fn)\n",
    "viewer.wm_title(model_filename)\n",
    "\n",
    "k = 1\n",
    "layers = ccnet.layers\n",
    "while k < len(outputs):\n",
    "    layer = layers[k]\n",
    "    layer1 = layers[k + 1] if k + 1 < len(layers) else None\n",
    "    layer2 = layers[k + 2] if k + 2 < len(layers) else None\n",
    "\n",
    "    if isinstance(layer, ConvLayer) and isinstance(layer1, NeuronLayer) and (\n",
    "            isinstance(layer2, PoolLayer)):\n",
    "        filters = layer.process.filters\n",
    "        out = outputs[k].reshape((-1,) + layer.shape_out)\n",
    "        out1 = outputs[k + 1].reshape((-1,) + layer.shape_out)\n",
    "        out2 = outputs[k + 2].reshape((-1,) + layer2.shape_out)\n",
    "        filter_fn = get_filters_image_fn(filters)\n",
    "        fn = get_act_image_fn(out)\n",
    "        fn1 = get_act_image_fn(out1)\n",
    "        fn2 = get_act_image_fn(out2)\n",
    "        title = \"%s/%s/%s\" % (layer.label, layer1.label, layer2.label)\n",
    "        viewer.add_column(\n",
    "            ('filters', 'acts', 'acts', 'acts'),\n",
    "            (filters, out, out1, out2),\n",
    "            (filter_fn, fn, fn1, fn2),\n",
    "            title=title)\n",
    "        k += 2\n",
    "    elif isinstance(layer, ConvLayer) and isinstance(layer1, NeuronLayer):\n",
    "        filters = layer.process.filters\n",
    "        out = outputs[k].reshape((-1,) + layer.shape_out)\n",
    "        out1 = outputs[k + 1].reshape((-1,) + layer.shape_out)\n",
    "        filter_fn = get_filters_image_fn(filters)\n",
    "        fn = get_act_image_fn(out)\n",
    "        fn1 = get_act_image_fn(out1)\n",
    "        title = \"%s/%s\" % (layer.label, layer1.label)\n",
    "        viewer.add_column(\n",
    "            ('filters', 'acts', 'acts'),\n",
    "            (filters, out, out1),\n",
    "            (filter_fn, fn, fn1),\n",
    "            title=title)\n",
    "        k += 1\n",
    "    elif isinstance(layer, ConvLayer):\n",
    "        filters = layer.process.filters\n",
    "        out = outputs[k].reshape((-1,) + layer.shape_out)\n",
    "        filter_fn = get_filters_image_fn(filters)\n",
    "        fn = get_act_image_fn(out)\n",
    "        viewer.add_filters_acts(filters, filter_fn, out, fn, title=layer.label)\n",
    "    elif isinstance(layer, PoolLayer):\n",
    "        out = outputs[k].reshape((-1,) + layer.shape_out)\n",
    "        fn = get_act_image_fn(out)\n",
    "        viewer.add_acts(out, fn, title=layer.label)\n",
    "    else:\n",
    "        print(\"Skipping %r\" % layer.label)\n",
    "\n",
    "    k += 1\n",
    "\n",
    "viewer.set_index(0)\n",
    "viewer.mainloop()"
   ]
  }
 ],
 "metadata": {
  "language_info": {
   "name": "python",
   "pygments_lexer": "ipython3"
  },
  "nbsphinx": {
   "execute": "never"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 2
}
